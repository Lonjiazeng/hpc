#  实验二： Linux环境下C语言编程与调试
| 作者 | 龙家增 |
| ---- | ------ |
##  （a）gcc、gdb学习总结	

+  **gcc:** 

  - gcc和g++是c/c++的linux系统集成的编译器，源文件的后缀应为 .C/.cpp/.c++/.cc等
  - 编译器可以将C、C++等语言源程序、汇编程序编译、链接成可执行程序。

+ **gdb** :

  - 是 GNU 开发的一个Unix/Linux下强大的程序调试工具。

+ **gcc详细介绍**：

  基本格式：gcc [options] file1 file2... //若不加入参数，则按默认参数依次执行编译、汇编和链接操作，生成的可执行文件名为 a.out
  常用参数：-E //只执行预处理操作
  　　　　　-S //只执行到编译操作完成，不进行汇编操作，生成的是汇编文件(.s 或 .asm),内容为汇编语言
  　　　　　-c //执行编译和汇编，但不进行链接，即只生成可重定位目标文件(.o),为二进制文件，不生成完整的可执行文件
  　　　　　-o filename //将操作后的内容输出到filename指定的文件中
  　　　　　-static //对于支持动态链接的系统，使用静态链接而不是动态链接进行链接操作
  　　　　　-g　　　　　　　　　 //编译时生成debug有关的程序信息(供gdb使用)
  　　　　　--save-temps //生成编译过程的中间结果文件(包括预处理文件(x.ii)、汇编代码(x.s)、目标文件(x.o)和最终的可执行文件)

  　　　　　-I PATH //在PATH指定的目录下寻找相关的include文件，参数中间不加空格
  　　　　　-lxx //其中xx为指定函数库，对于Linux环境下的函数库，静态库后缀为.a,动态库后缀为.so，一般库名为libxx.a或libxx.so,如加入libm.so库，则使用参数-lm(去除lib和后缀.a\so)
  　　　　　-L PATH //在PATH指定的目录下寻找相关的库文件，即-lxx指定待链接的库，-L指定寻找该库的路径。不指定时搜索默认的库函数路径。

  　　　　　-std=xx //指定编译使用的语言标准,如 -std=c++11 使用 c++11 标准
  　　　　　-x language //指定待编译文件的语言，而不是由编译器根据文件后缀自行判断。即默认情况下gcc根据文件后缀判断使用的编程语言。例如使用文件名hello作为源文件名是不合适的，应使用hello.c
  　　　　　
  　　　　　-Wall //输出一些简单的错误以及一些可能存在问题的警告
  　　　　　-Wextra //输出-Wall不包含的警告等
  　　　　　-Werror //将警告视为错误输出
  　　
  　　　　　-Wl,option　　　　　　　　　 //通过该选项将参数 option 作为后续链接器 ld 使用的参数
  　　　　　-Wl,rpath=/path/to/lib　　//为链接器指定一个非默认的运行时库的搜索路径，运行采用了该选项编译的程序时，链接器会在-rpath 指定的目录中搜索所需的 so 库文件，以将其载入内存中
  　　　
  　　　　　-D name=definition //加入宏定义，若不指定def，则默认为1
  　　　　　-O1、-O2　　　　　　　//规定编译器的优化等级，优化级数越高执行效率一般越好，但是优化会改变原有程序结构，使得其汇编不易理解

  　　　　　//一些进行缓冲区溢出实验时可能需要的选项
  　　　　　-fstack-protector-fno-stack-protector　　//是否开启堆栈保护，这里的保护是在返回地址之前加入一个验证值来确保返回地址不被破坏
  　　　　　-z execstack 　　　　　　　　　　　　　　　　　//启用可执行栈，默认是禁用的
  　　　　　//（echo 0 >/proc/sys/kernel/randomize_va_space 关闭地址随机化，这是一个单独的命令,操作需要root权限）

+ **gdb详细介绍**：

  - `xxx: gdb + 空格 + 文件名` -- 进入gdb

  - `(gdb) run + 回车` -- 运行程序并显示运行结果

  - `(gdb) break + 某位置` -- 在某位置处设置断点，例如`break main`--在main函数处设置断点

  - `(gdb) run + 回车` -- 再次运行，并在断点处停下来 （注：显示程序位置、断点信息、断点处代码）

  - `(gdb) next + 回车` -- next键入后才会开始执行 （注：显示下一行尚未执行的代码）

  - `(gdb) print + 某变量名` -- 查看此时某变量名的值 （注：print结果以美元符号$开头+顺序数组+变量值）

  - `(gdb) next.....` -- 继续执行等等

  - `(gdb) continue + 回车` -- 取消断点

  - `(gdb) run` -- 又停在断点处

  - `(gdb) next`

  - `(gdb) step` -- 进入某函数

  - `(gdb) list` -- 查看gdb上下文，即代码

  - ```
    (gdb) backtrack
    ```

     

    -- 回溯位置

    - 井号0：现在的位置
    - 井号1：之前从哪里来的位置

  - `(gdb) q` -- 退出debug

  

  

  

  ##  （b）GEMM实现的时间对比分析，尝试N取不同的值，测量 时间并绘制折线图

  ​	相关代码放在code文件夹中，其中Matrix.c是普通矩阵乘法的相关代码，Blas.c为使用OpenBLAS库相关函数的代码。获得的数据存放在文件夹data中，其中Record.txt为Matrix.c产生的文件，OpenBLAS_Record.txt为Blas.c产生的文件。将两个文件的内容分析制作成折线图如下：

  ![image-20210920180512509](https://github.com/Lonjiazeng/hpc/blob/main/lib2/image-20210920180512509.png)

  纵轴为时间，单位秒，横轴为矩阵大小，A、B、C均为n×n矩阵。详细信息可在data文件夹中的excel文件中查看。

  ​	通过上表可以看出，随着计算规模的增大，计算耗时逐渐增加，但OpenBLAS库函数的实现增长较为缓慢，除极个别可排除的数据外，基本在0.5秒以下即可计算完成。普通矩阵乘法在n接近600时即突破0.5秒，随后增长较快，在n接近1000时突破2.5秒，是蓝线的5倍。

  

  

